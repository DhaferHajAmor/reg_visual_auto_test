<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Visual Diff â€” ZÃ©roâ€‘installation</title>
  <link rel="stylesheet" href="styles.css" />
  <meta name="description" content="Superposez un PNG Figma sur nâ€™importe quel site via un bookmarklet, ou comparez deux images avec un diff pixel. Aucune installation." />
  <link rel="icon" href="data:," />
  <script defer src="scripts/image-diff.js"></script>
</head>
<body>
  <header class="container">
    <h1>Visual Diff</h1>
    <p class="subtitle">Comparaison visuelle sans installation pour pages et images.</p>
    <div class="hero">
  <p>Glissez le bookmarklet dans votre barre de favoris pour comparer votre design Figma en direct. Besoin dâ€™un simple diff ? Utilisez le mode image â†” image.</p>
      <div class="cta-row">
        <a id="bookmarkletLinkTop" class="btn" href="#">Superposition en direct</a>
        <button id="copyBookmarklet" class="btn secondary" type="button">Copier le bookmarklet</button>
      </div>
    </div>
  </header>  

  <main class="container">
    <nav class="tabs" role="tablist" aria-label="Modes">
  <button class="tab active" data-tab="image-diff" role="tab" aria-selected="true">Image â†” Image</button>
  <button class="tab" data-tab="bookmarklet" role="tab" aria-selected="false">Superposition (Bookmarklet)</button>
    </nav>

    <section id="image-diff" class="tabpanel active" role="tabpanel">
      <h2>Comparaison Image â†” Image</h2>
      <div class="dropzones">
        <div class="dropzone" data-side="A">
          <p>Image de rÃ©fÃ©rence</p>
          <button type="button" class="btn secondary pick">Choisir une image</button>
          <small class="fname"></small>
          <input type="file" accept="image/png,image/jpeg,image/webp" class="sr-only" />
          <img alt="" aria-hidden="true" />
        </div>
        <div class="dropzone" data-side="B">
          <p>Image Ã  comparer</p>
          <button type="button" class="btn secondary pick">Choisir une image</button>
          <small class="fname"></small>
          <input type="file" accept="image/png,image/jpeg,image/webp" class="sr-only" />
          <img alt="" aria-hidden="true" />
        </div>
      </div>
  <div class="controls-row" style="justify-content:center">
        <label>Mode <select id="diffMode"><option value="pixel">Pixel (rapide)</option><option value="ssim">SSIM (perceptuel)</option></select> <span class="help" title="SSIM: mesure de similaritÃ© structurelle (plus proche de la perception humaine)">i</span></label>
        <label><span id="thresholdLabelText">Seuil</span> <input id="threshold" type="range" min="0" max="100" value="8" /> <span id="thresholdVal">8%</span></label>
        <label>Couleur <input id="diffColor" type="color" value="#ff0055" /></label>
      </div>
  <div class="controls-row" style="justify-content:center">
        <label><input type="checkbox" id="lumaOnly" /> Luminance seule <span class="help" aria-label="Aide" title="Compare uniquement la luminositÃ© (Y). RÃ©duit les Ã©carts de teinte mineurs, utile pour le texte.">i</span></label>
        <label><input type="checkbox" id="blur1" /> Lisser (1Â px) <span class="help" aria-label="Aide" title="Applique un lÃ©ger flou (1Â px) avant la comparaison pour attÃ©nuer lâ€™anticrÃ©nelage.">i</span></label>
  <label><input type="checkbox" id="edgeTol" /> TolÃ©rance bords (AA) <span class="help" aria-label="Aide" title="Augmente la tolÃ©rance prÃ¨s des bords forts (anticrÃ©nelage) pour rÃ©duire les faux positifs.">i</span></label>
      </div>
      <div class="controls-row" style="justify-content:center">
  <button id="maskToggle" class="btn-outline" type="button">Ignorer une zone</button>
  <button id="maskClear" class="btn secondary" type="button">Effacer zones ignorÃ©es</button>
	<button id="focusZoneToggle" class="btn-outline" type="button">Zone de focus</button>
	<button id="focusZoneClear" class="btn secondary" type="button">Effacer focus</button>
      </div>
      <div class="controls-row" style="justify-content:center">
        <button id="runDiff" class="btn secondary">Lancer le diff</button>
        <button id="swapImages" class="btn secondary">Inverser</button>
        <button id="clearImages" class="btn secondary">Effacer</button>
    <button id="detectShift" class="btn secondary" type="button">DÃ©tecter dÃ©calage</button>
    <button id="resetShift" class="btn secondary" type="button">RÃ©init. dÃ©calage</button>
      </div>
      <div class="controls-row" style="justify-content:center">
        <button id="resetPrefs" class="btn secondary" type="button">RÃ©initialiser prÃ©fÃ©rences</button>
        <button id="downloadDiff" class="btn secondary" type="button">TÃ©lÃ©charger le diff</button>
      </div>
      <div class="controls-row" style="justify-content:center">
  <span id="sizeIgnoredBadge" class="badge-size-ignored" style="display:none" aria-live="polite" aria-label="Les images ont des tailles diffÃ©rentes; seule la zone commune est comparÃ©e">Tailles diffÃ©rentes</span>
  <span id="shiftInfo" class="badge-size-ignored" style="display:none;background:#00873e;color:#fff" aria-live="polite" aria-label="DÃ©calage global appliquÃ©"></span>
      </div>
  <div id="diffStatus" class="tip" aria-live="polite" style="display:none;text-align:center;font-weight:600"></div>
      <div id="diffContainer" class="diff-wrap">
        <canvas id="diffCanvas" class="canvas" aria-label="RÃ©sultat du diff"></canvas>
        <canvas id="maskCanvas" class="mask-canvas" aria-label="Masques de zones ignorÃ©es"></canvas>
        <div id="diffSpinner" class="diff-spinner hidden" aria-live="polite" aria-atomic="true">
          <div class="ring" aria-hidden="true"></div>
          <span>Calculâ€¦</span>
        </div>
      </div>
  <div class="tip">DÃ©posez deux images ou utilisez les sÃ©lecteurs. Lâ€™aperÃ§u sous chaque zone montre lâ€™image chargÃ©e. Utilisez Â«Â Ignorer une zoneÂ Â» pour dessiner un rectangle exclu de la comparaison. Le diff met en Ã©vidence les pixels qui diffÃ¨rent auâ€‘delÃ  du seuil choisi.</div>
  <div class="tip"><strong>Conseils</strong>Â : Texte fin â†’ Luminance + Lisser (1Â px) + seuil 8â€“15%. IcÃ´nes/solides â†’ Mode Pixel, tolÃ©rance bords off, seuil bas. Visuel global â†’ Mode SSIM.</div>
    </section>

    <section id="bookmarklet" class="tabpanel" role="tabpanel" aria-hidden="true">
      <h2>Superposition en direct (Bookmarklet)</h2>
      <ol>
  <li>Glissez ceci dans votre barre de favorisÂ : <a id="bookmarkletLink" href="#">Superposition en direct</a></li>
        <li>Visitez nâ€™importe quelle page et cliquez sur le bookmarklet.</li>
        <li>Importez votre PNG Figma et alignezâ€‘le Ã  lâ€™aide des contrÃ´les.</li>
      </ol>
      <details>
        <summary>Ã€ quoi Ã§a sertÂ ?</summary>
        <p>Il injecte une petite interface dans la page (entiÃ¨rement cÃ´tÃ© navigateur). Vous pouvez positionner, mettre Ã  lâ€™Ã©chelle et changer le mode de fusion de votre PNG pour comparer le design et le rendu.</p>
      </details>
      <div class="tip">AstuceÂ : flÃ¨ches pour dÃ©placer (Maj = 10Â px), +/- pour lâ€™Ã©chelle, D pour le mode difference, Ã‰chap pour fermer.</div>
    </section>
  </main>

  <footer class="container small">
  <p>Tout se passe dans votre navigateur. Aucune donnÃ©e nâ€™est envoyÃ©e.</p>
  </footer>

  <script id="visdiff-bookmarklet-code" type="text/plain">
(()=>{if(window.__VIS_DIFF__&&window.__VIS_DIFF__.open){window.__VIS_DIFF__.open();return}const d=document;const st=d.createElement('style');st.textContent=`
.visdiff-overlay-root{position:fixed;inset:0;pointer-events:none;z-index:2147483647}
.visdiff-panel{position:fixed;top:16px;right:16px;background:var(--ov-panel);color:var(--ov-text);border:1px solid var(--ov-border);border-radius:10px;padding:10px;min-width:320px;pointer-events:auto;box-shadow:0 6px 24px rgba(0,0,0,.35);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
.visdiff-panel h3{margin:0 0 8px 0;font-size:16px}
.visdiff-close-btn{position:absolute;top:6px;right:6px;width:28px;height:28px;line-height:24px;font-size:18px;font-weight:600;padding:0;background:var(--ov-btn);border:1px solid var(--ov-btn-border);color:var(--ov-btn-text);border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center}
.visdiff-close-btn:hover{filter:brightness(1.08)}
.visdiff-close-btn:active{transform:translateY(1px)}
.visdiff-row{display:flex;gap:8px;align-items:center;margin:6px 0;flex-wrap:wrap}
.visdiff-row label{font-size:12px;color:var(--ov-muted)}
.visdiff-row input[type=range]{width:120px;margin:0}
.visdiff-row label{display:flex;align-items:center;gap:4px}
.visdiff-row input[type=number]{padding:2px 4px}
.visdiff-row select{height:28px}
.visdiff-buttons{display:flex;gap:8px;flex-wrap:wrap}
.visdiff-help{display:inline-block;width:16px;height:16px;line-height:16px;text-align:center;border-radius:50%;background:var(--ov-btn);border:1px solid var(--ov-btn-border);color:var(--ov-text);font-size:11px;margin-left:6px;cursor:help}
.visdiff-btn{background:var(--ov-btn);border:1px solid var(--ov-btn-border);color:var(--ov-btn-text);padding:6px 10px;border-radius:8px;cursor:pointer}
.visdiff-btn.danger{border-color:var(--ov-danger-border);background:var(--ov-danger-bg);color:#ffc8d7}
.visdiff-stage{position:fixed;inset:0;pointer-events:none}
.visdiff-floating{position:absolute;left:0;top:0;transform-origin:top left;pointer-events:auto;cursor:move;touch-action:none}
.visdiff-floating img{display:block;max-width:none;border:none;border-radius:0;box-shadow:none;}
.visdiff-floating::after{content:none;}
.visdiff-hidden{display:none !important}
.visdiff-grid{position:fixed;inset:0;pointer-events:none;--s:8px;--o:.2;--c:var(--ov-grid-rgba, rgba(122,162,255,.6));background-image:repeating-linear-gradient(0deg,var(--c) 0 1px,transparent 1px,var(--s)),repeating-linear-gradient(90deg,var(--c) 0 1px,transparent 1px,var(--s));opacity:var(--o)}
.visdiff-loupe{position:fixed;width:160px;height:160px;border:2px solid var(--ov-accent);border-radius:50%;overflow:hidden;pointer-events:none;box-shadow:0 4px 18px rgba(0,0,0,.4);z-index:2147483647}
.visdiff-loupe img{position:absolute;transform-origin:top left;image-rendering:pixelated}
.visdiff-handle{position:fixed;top:0;bottom:0;width:2px;background:var(--ov-accent);box-shadow:0 0 0 1px color-mix(in srgb, var(--ov-accent) 30%, transparent);cursor:ew-resize;pointer-events:auto}
.visdiff-knob{position:absolute;top:50%;left:-8px;width:18px;height:18px;border-radius:50%;background:var(--ov-accent);border:2px solid var(--ov-knob-border);transform:translateY(-50%)}
.visdiff-crop-layer{position:fixed;inset:0;cursor:crosshair;pointer-events:auto;background:rgba(0,0,0,.25);z-index:2147483646}
.visdiff-crop-rect{position:absolute;border:2px dashed var(--ov-accent);background:rgba(0,135,62,.12)}
.visdiff-new{outline:2px dashed #ff9800;outline-offset:2px;position:relative}
.visdiff-new::after{content:'Nouveau';position:absolute;top:-10px;right:-2px;background:#ff9800;color:#fff;font:10px/1.2 system-ui;padding:2px 4px;border-radius:4px;pointer-events:none}
.visdiff-new-part{outline:2px solid #ffc107;outline-offset:2px;position:relative}
.visdiff-new-part::after{content:'Partiel';position:absolute;top:-10px;right:-2px;background:#ffc107;color:#222;font:10px/1.2 system-ui;padding:2px 4px;border-radius:4px;pointer-events:none}
`;d.documentElement.appendChild(st);
const root=d.createElement('div');root.className='visdiff-overlay-root visdiff-hidden';
const stage=d.createElement('div');stage.className='visdiff-stage';root.appendChild(stage);
const grid=d.createElement('div');grid.className='visdiff-grid visdiff-hidden';stage.appendChild(grid);
const float=d.createElement('div');float.className='visdiff-floating';const img=d.createElement('img');img.alt='Overlay';float.appendChild(img);stage.appendChild(float);
const loupe=d.createElement('div');loupe.className='visdiff-loupe visdiff-hidden';const lImg=d.createElement('img');loupe.appendChild(lImg);stage.appendChild(loupe);
const handle=d.createElement('div');handle.className='visdiff-handle visdiff-hidden';const knob=d.createElement('div');knob.className='visdiff-knob';handle.appendChild(knob);stage.appendChild(handle);
// Split-view wrapper for performant masking (instead of clip-path)
const splitWrapper=d.createElement('div');
splitWrapper.className='visdiff-split-wrapper';
splitWrapper.style.cssText='position:fixed;top:0;bottom:0;left:0;overflow:hidden;pointer-events:auto;';
// move float inside wrapper so it gets clipped by width
try{ stage.removeChild(float); }catch(_){}
splitWrapper.appendChild(float);
stage.appendChild(splitWrapper);
// Ensure handle stays on top of wrapper for interactions
try{ stage.appendChild(handle); }catch(_){}
// Crop layer (for area selection)
const cropLayer=d.createElement('div');cropLayer.className='visdiff-crop-layer visdiff-hidden';const cropRect=d.createElement('div');cropRect.className='visdiff-crop-rect';cropLayer.appendChild(cropRect);root.appendChild(cropLayer);
const panel=d.createElement('div');panel.className='visdiff-panel';panel.innerHTML=`<div class="visdiff-header" style="position:relative;padding-right:34px"><h3 style="margin:0;font-size:15px">Superposition visuelle</h3><button id="vdclose" class="visdiff-close-btn" aria-label="Fermer" title="Fermer" type="button">Ã—</button></div>
<div class="visdiff-row"><button id="vdpick" class="visdiff-btn" type="button">Choisir une image</button><small id="vdfname" style="color:var(--ov-muted)"></small><input type="file" accept="image/*" id="vdupload" aria-label="Importer une image" style="display:none"></div>
<div class="visdiff-row"><label>OpacitÃ©</label><input type="range" id="vdopacity" min="0" max="100" value="60"><span id="vdopval">60%</span><label>Ã‰chelle</label><input type="range" id="vdscale" min="10" max="400" value="100"><span id="vdscval">100%</span></div>
<div class="visdiff-row"><label>X</label><input type="number" id="vdx" value="0" style="width:80px"><label>Y</label><input type="number" id="vdy" value="0" style="width:80px"></div>
<div class="visdiff-row"><label>Fusion</label><select id="vdblend"><option value="normal">normal</option><option value="multiply">multiply</option><option value="screen">screen</option><option value="overlay">overlay</option><option value="darken">darken</option><option value="lighten">lighten</option><option value="difference">difference</option><option value="color-dodge">color-dodge</option><option value="color-burn">color-burn</option><option value="hard-light">hard-light</option><option value="soft-light">soft-light</option></select></div>
<div class="visdiff-row"><label>Grille</label><input type="checkbox" id="vdgrid"><label>Pas</label><input type="number" id="vdgridsp" min="4" max="64" value="8" style="width:70px"><label>OpacitÃ©</label><input type="range" id="vdgrido" min="0" max="100" value="20"></div>
<div class="visdiff-row"><label>Couleur de la grille</label><span class="visdiff-help" title="Change uniquement la couleur du quadrillage dâ€™alignement.">i</span><input type="color" id="vdgridc" value="#7aa2ff"></div>
<div class="visdiff-row"><label>Loupe</label><input type="checkbox" id="vdloupe"><label>Taille</label><input type="range" id="vdloupes" min="100" max="300" value="160"><label>Zoom</label><input type="range" id="vdloupez" min="200" max="800" value="300"></div>
<div class="visdiff-row"><label>Curseur</label><input type="checkbox" id="vdsld"><label>Position</label><input type="range" id="vdsldp" min="0" max="100" value="50"></div>
<!-- Option 'Fixe viewport' supprimÃ©e: comportement dÃ©sormais implicite (overlay reste fixe Ã  l'Ã©cran lors du scroll) -->
<div class="visdiff-buttons"><button id="vdexport" class="visdiff-btn">Exporter l'overlay</button><button id="vdcenter" class="visdiff-btn">Centrer overlay</button><button id="vdhide" class="visdiff-btn">Masquer overlay</button></div>
<div class="visdiff-buttons"><button id="vdadapt" class="visdiff-btn">Adapter dimensions overlay</button><button id="vdreset" class="visdiff-btn">RÃ©initialiser</button></div>
<div class="visdiff-row" style="font-size:12px;color:#a7acc6">FlÃ¨ches: dÃ©placer | +/-: Ã©chelle | D: difference | G: grille | L: loupe | S: curseur | X: export | P: capture | H: UI | Ã‰chap: fermer</div>`;
root.appendChild(panel);d.documentElement.appendChild(root);
// ThÃ¨me fixÃ©: Desjardins
const palettes={
  desjardins:{panel:'#ffffff',text:'#0f231a',border:'#cfe7da',muted:'#55655d',btn:'#e8f3ee',btnBorder:'#cfe7da',btnText:'#0f231a',accent:'#00873e',knobBorder:'#dfeae6',dangerBg:'#fde8ee',dangerBorder:'#f5b3c7'}
};
const pal=palettes.desjardins;
root.style.setProperty('--ov-panel', pal.panel);
root.style.setProperty('--ov-text', pal.text);
root.style.setProperty('--ov-border', pal.border);
root.style.setProperty('--ov-muted', pal.muted);
root.style.setProperty('--ov-btn', pal.btn);
root.style.setProperty('--ov-btn-border', pal.btnBorder);
root.style.setProperty('--ov-btn-text', pal.btnText);
root.style.setProperty('--ov-accent', pal.accent);
root.style.setProperty('--ov-knob-border', pal.knobBorder);
root.style.setProperty('--ov-danger-bg', pal.dangerBg);
root.style.setProperty('--ov-danger-border', pal.dangerBorder);
let open=false,showUI=true;
const $=sel=>panel.querySelector(sel);
const btnPick=$('#vdpick');let fileInput=$('#vdupload');const fnLabel=$('#vdfname');const opInput=$('#vdopacity');const opVal=$('#vdopval');const scInput=$('#vdscale');const scVal=$('#vdscval');const xInput=$('#vdx');const yInput=$('#vdy');const blendSel=$('#vdblend');const btnHide=$('#vdhide');const btnCenter=$('#vdcenter');const btnAdapt=$('#vdadapt');const btnReset=$('#vdreset');const btnClose=$('#vdclose');
// Viewport lock (implicit now, no UI checkbox)
// (Options dÃ©tection nouveautÃ©s retirÃ©es)
// (diagnostic fusionnÃ© dans le bouton d'adaptation)
const gridChk=$('#vdgrid');const gridSp=$('#vdgridsp');const gridOp=$('#vdgrido');const gridColor=$('#vdgridc');
const loupeChk=$('#vdloupe');const loupeSize=$('#vdloupes');const loupeZoom=$('#vdloupez');
const sldChk=$('#vdsld');const sldPos=$('#vdsldp');
const btnExport=$('#vdexport');
let posX=0,posY=0,scale=1,opacity=.6,blend='normal';
// Viewport lock state: when active, overlay stays visually fixed during scroll
// Anchor mode: 'document' (overlay scrolls with page content) or 'viewport' (stays fixed)
let anchorMode='document';
let prevOpacityForDiff=null;
let gOn=false,gSp=8,gOp=.2,gCol='#7aa2ff';
let lOn=false,lSize=160,lZ=3;
let sOn=false,sPct=50;
let lastURL=null;
// Track if user manually moved/adjusted overlay to avoid intrusive auto recenters
let userMovedOverlay=false;
[xInput,yInput,scInput,opInput].forEach(el=>{ if(el) el.addEventListener('input', ()=>{ userMovedOverlay=true; }); });
float.addEventListener('pointerdown', ()=>{ userMovedOverlay=true; });
// (fonctionnalitÃ© Nouveaux Ã©lÃ©ments supprimÃ©e)
// Update split wrapper width and handle position based on sPct/sOn
function updateSplitVisual(){
  const w=window.innerWidth||0; const pct=Math.max(0,Math.min(100,Number(sPct)||0));
  const sPx=Math.round((pct/100)*w);
  if(sOn){
    splitWrapper.style.width=sPx+'px';
    // Anchor handle at left then translate to desired x
    handle.style.left='0px';
    handle.style.transform=`translateX(${Math.max(0,Math.min(sPx,w-2))}px)`;
  } else {
    splitWrapper.style.width=w+'px';
    handle.style.transform='';
  }
}
window.addEventListener('resize', updateSplitVisual);
const KEY='VD::'+location.host;function save(){clearTimeout(save.t);save.t=setTimeout(()=>{try{localStorage.setItem(KEY,JSON.stringify({posX,posY,scale,opacity,blend,gOn,gSp,gOp,gCol,lOn,lSize,lZ,sOn,sPct,anchorMode}))}catch(_){}},300)}
function load(){try{const v=JSON.parse(localStorage.getItem(KEY)||'{}');if(typeof v.posX==='number')posX=v.posX;if(typeof v.posY==='number')posY=v.posY;if(typeof v.scale==='number')scale=v.scale;if(typeof v.opacity==='number')opacity=v.opacity;if(typeof v.blend==='string')blend=v.blend;gOn=!!v.gOn;gSp=v.gSp||8;gOp=typeof v.gOp==='number'?v.gOp:.2;gCol=v.gCol||'#7aa2ff';lOn=!!v.lOn;lSize=v.lSize||160;lZ=v.lZ||3;sOn=!!v.sOn;sPct=(typeof v.sPct==='number'?v.sPct:50);if(v.anchorMode==='viewport'||v.anchorMode==='document')anchorMode=v.anchorMode;}catch(_){} }
function hexToRgb(h){const m=/^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(h);return m?{r:parseInt(m[1],16),g:parseInt(m[2],16),b:parseInt(m[3],16)}:{r:122,g:162,b:255}}
function apply(){
  const dispX = anchorMode==='document'? (posX - window.scrollX) : posX;
  const dispY = anchorMode==='document'? (posY - window.scrollY) : posY;
  float.style.left=dispX+'px';float.style.top=dispY+'px';float.style.transform=`scale(${scale})`;img.style.opacity=opacity;img.style.mixBlendMode=blend;
  xInput.value=String(Math.round(posX));yInput.value=String(Math.round(posY));
  scInput.value=String(Math.round(scale*100));scVal.textContent=Math.round(scale*100)+'%';opInput.value=String(Math.round(opacity*100));opVal.textContent=Math.round(opacity*100)+'%';
grid.classList.toggle('visdiff-hidden',!gOn);gridSp.value=String(gSp);gridOp.value=String(Math.round(gOp*100));gridChk.checked=gOn;gridColor.value=gCol;const c=hexToRgb(gCol);grid.style.setProperty('--s',gSp+'px');grid.style.setProperty('--o',String(gOp));grid.style.setProperty('--c',`rgba(${c.r},${c.g},${c.b},0.6)`);
loupe.classList.toggle('visdiff-hidden',!lOn||!img.src);loupe.style.width=lSize+'px';loupe.style.height=lSize+'px';loupeChk.checked=lOn;loupeSize.value=String(lSize);loupeZoom.value=String(Math.round(lZ*100));
// slider
sldChk.checked=sOn;sldPos.value=String(Math.round(sPct));handle.classList.toggle('visdiff-hidden',!sOn);
updateSplitVisual();
save()}
function reset(){posX=0;posY=0;scale=1;opacity=.6;blend='normal';gOn=false;gSp=8;gOp=.2;gCol='#7aa2ff';lOn=false;lSize=160;lZ=3;apply();}
function setBlend(b){
  // Auto-max opacity when entering difference for visibility; restore when leaving
  if(b==='difference' && blend!=="difference"){
    prevOpacityForDiff = opacity;
    opacity = 1; if(opInput){ opInput.value='100'; opVal.textContent='100%'; }
  } else if(blend==='difference' && b!=="difference" && prevOpacityForDiff!=null){
    opacity = prevOpacityForDiff; prevOpacityForDiff=null;
    if(opInput){ const v=Math.round(opacity*100); opInput.value=String(v); opVal.textContent=v+'%'; }
  }
  blend=b; if(blendSel){ blendSel.value=b; }
  apply();
}
function openUI(){open=true;root.classList.remove('visdiff-hidden');panel.classList.toggle('visdiff-hidden',!showUI)}
function closeUI(){open=false;root.classList.add('visdiff-hidden');panel.classList.add('visdiff-hidden')}
function toggleUI(force){if(typeof force==='boolean')showUI=force;else showUI=!showUI;panel.classList.toggle('visdiff-hidden',!showUI)}
// Full teardown: revoke blob URL, remove injected DOM and globals
// Fonction de diagnostic avec corrections automatiques
function diagnoseOverlayFit(ev) {
  const verbose = !!(ev && ev.altKey);
  const started = performance.now();
  const groupLabel = verbose ? 'ðŸ”¬ Diagnostic overlay (verbose)' : 'ðŸ”¬ Diagnostic overlay';
  if(console.groupCollapsed) console.groupCollapsed(groupLabel);
  if (!img || !img.src){ console.error('âŒ Aucune image chargÃ©e'); if(console.groupEnd) console.groupEnd(); return; }

  const naturalW = img.naturalWidth;
  const naturalH = img.naturalHeight;
  let overlayW = naturalW * scale;
  let overlayH = naturalH * scale;

  const methods = {
    scroll:{ w:Math.max(document.documentElement.scrollWidth,document.body.scrollWidth), h:Math.max(document.documentElement.scrollHeight,document.body.scrollHeight) },
    offset:{ w:Math.max(document.documentElement.offsetWidth,document.body.offsetWidth), h:Math.max(document.documentElement.offsetHeight,document.body.offsetHeight) },
    client:{ w:Math.max(document.documentElement.clientWidth,document.body.clientWidth), h:Math.max(document.documentElement.clientHeight,document.body.clientHeight) },
    rect:(()=>{ const html=document.documentElement.getBoundingClientRect(); const body=document.body.getBoundingClientRect(); return { w:Math.max(html.width,body.width), h:Math.max(html.height,body.height) }; })()
  };

  let best=null, smallest=Infinity;
  for(const [k,d] of Object.entries(methods)){
    const diff = Math.abs(overlayW-d.w)+Math.abs(overlayH-d.h);
    if(diff<smallest){ smallest=diff; best={method:k,diffW:Math.abs(overlayW-d.w),diffH:Math.abs(overlayH-d.h),dims:d}; }
    if(verbose) console.log(` Â· ${k}: ${d.w} x ${d.h} (Î” ${Math.abs(overlayW-d.w).toFixed(1)} / ${Math.abs(overlayH-d.h).toFixed(1)})`);
  }
  if(verbose) console.log(`âœ… MÃ©thode retenue: ${best.method} (Ã©cart total ${(best.diffW+best.diffH).toFixed(1)})`);

  const bodyStyles = window.getComputedStyle(document.body);
  const zoomOuter = window.outerWidth && window.innerWidth ? +(window.outerWidth/window.innerWidth).toFixed(2) : 1;
  const dpr = window.devicePixelRatio || 1;

  let corrections=0; const notes=[];

  // Ajustement Ã©chelle (limite variation)
  if(best.diffW>2 || best.diffH>2){
    const targetScale = Math.min(best.dims.w / naturalW, best.dims.h / naturalH);
    const delta = Math.abs(targetScale - scale);
    if(delta > 0.005 && delta < 0.5){
      scale = targetScale; scInput.value=String(Math.round(scale*100)); overlayW=naturalW*scale; overlayH=naturalH*scale; corrections++; notes.push(`Ã‰chelle â†’ ${Math.round(scale*100)}%`);
    } else if(verbose){ console.log('Ã‰chelle: ajustement ignorÃ© (delta trop faible ou trop grand)'); }
  }

  // Recentrage si pas d'action utilisateur prÃ©alable
  if(!userMovedOverlay){
    const curCX = posX + overlayW/2; const curCY = posY + overlayH/2;
    const tgtCX = best.dims.w/2; const tgtCY = best.dims.h/2;
    if(Math.abs(curCX-tgtCX)>10 || Math.abs(curCY-tgtCY)>10){
      posX = tgtCX - overlayW/2; posY = tgtCY - overlayH/2; corrections++; notes.push('Recentrage');
    }
  } else if(verbose) { console.log('Recentrage sautÃ© (utilisateur a dÃ©jÃ  dÃ©placÃ©)'); }

  // Scrollbars compensation dynamique
  const vBar = window.innerWidth - document.documentElement.clientWidth; // largeur barre vert.
  const hBar = window.innerHeight - document.documentElement.clientHeight;
  if(vBar>0 && posX + overlayW > best.dims.w - vBar){ posX = best.dims.w - overlayW - vBar; corrections++; notes.push('Ajustement barre verticale'); }
  if(hBar>0 && posY + overlayH > best.dims.h - hBar){ posY = best.dims.h - overlayH - hBar; corrections++; notes.push('Ajustement barre horizontale'); }

  if(corrections){ apply(); updateLockOffsets(); }

  // VÃ©rification finale
  const finalW = naturalW*scale; const finalH = naturalH*scale;
  const finalDiffW = Math.abs(finalW - best.dims.w); const finalDiffH = Math.abs(finalH - best.dims.h);
  const success = finalDiffW<=2 && finalDiffH<=2;

  if(verbose){
    console.log('RÃ©sultat final:', { overlay:`${Math.round(finalW)}x${Math.round(finalH)}`, page:`${best.dims.w}x${best.dims.h}`, diff:`${finalDiffW.toFixed(1)} / ${finalDiffH.toFixed(1)}` });
    console.log('Styles body margin/padding:', bodyStyles.margin, bodyStyles.padding);
    console.log('Zoom outer ratio:', zoomOuter, 'DPR:', dpr);
  }

  // Toast helper
  function showToast(msg){
    let t=document.querySelector('.visdiff-toast');
    if(!t){ t=document.createElement('div'); t.className='visdiff-toast'; t.style.cssText='position:absolute;left:10px;right:10px;bottom:8px;padding:6px 10px;font:12px system-ui;background:var(--ov-panel);color:var(--ov-text);border:1px solid var(--ov-border);border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,.35);pointer-events:none;opacity:0;transition:opacity .25s'; panel.appendChild(t); }
    t.textContent=msg; requestAnimationFrame(()=>{ t.style.opacity='1'; }); clearTimeout(t._h); t._h=setTimeout(()=>{ t.style.opacity='0'; }, 2500);
  }

  if(corrections){
    showToast('Corrections: '+notes.join(', '));
  } else {
    showToast(success ? 'DÃ©jÃ  optimal' : 'Diff rÃ©siduelle '+finalDiffW.toFixed(1)+'px/'+finalDiffH.toFixed(1)+'px');
  }

  if(!verbose){
    console.log(`Diagnostic: ${corrections} correction(s). Diff finale ${finalDiffW.toFixed(1)} / ${finalDiffH.toFixed(1)}${success?' âœ…':''}`);
  }
  if(console.groupEnd) console.groupEnd();
  const elapsed = (performance.now()-started).toFixed(1);
  if(verbose) console.log('â± DurÃ©e ms:', elapsed);
  updateLockOffsets();
  return { corrections, finalDiffW, finalDiffH, scale, posX, posY };
}

// Fonction d'auto-correction au chargement de l'image
function autoCorrectOnImageLoad() {
  if (!img || !img.src) return;

  console.log('ðŸš€ AUTO-CORRECTION: Analyse automatique au chargement');

  // Attendre que l'image soit complÃ¨tement chargÃ©e
  if (img.complete) {
    // DÃ©lai court pour s'assurer que tout est prÃªt
    setTimeout(() => {
      const overlayWidth = img.naturalWidth * scale;
      const overlayHeight = img.naturalHeight * scale;

      // VÃ©rifier s'il y a un dÃ©calage important
      const pageWidth = Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);
      const pageHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);

      const diffWidth = Math.abs(overlayWidth - pageWidth);
      const diffHeight = Math.abs(overlayHeight - pageHeight);

      if (diffWidth > 10 || diffHeight > 10) {
        console.log('âš ï¸ DÃ©calage dÃ©tectÃ©, correction automatique...');
        diagnoseOverlayFit();
      } else {
        console.log('âœ… Pas de dÃ©calage significatif dÃ©tectÃ©');
      }
    }, 500);
  } else {
    // Si l'image n'est pas encore chargÃ©e, attendre l'Ã©vÃ©nement load
    img.addEventListener('load', () => {
      setTimeout(() => {
        autoCorrectOnImageLoad();
      }, 500);
    });
  }
}

// Activer l'auto-correction quand une nouvelle image est chargÃ©e
const originalHandleFileSelection = window.handleFileSelection;
if (typeof originalHandleFileSelection === 'function') {
  window.handleFileSelection = function(...args) {
    originalHandleFileSelection.apply(this, args);
    setTimeout(autoCorrectOnImageLoad, 1000);
  };
}

function destroyOverlay(){
  try{ if(lastURL){ URL.revokeObjectURL(lastURL); lastURL=null; } }catch(_){ }
  try{ if(root && root.parentNode){ root.parentNode.removeChild(root); } }catch(_){ }
  try{ if(st && st.parentNode){ st.parentNode.removeChild(st); } }catch(_){ }
  try{ delete window.__VIS_DIFF__; }catch(_){ }
}
function handleFileSelection(e){
  const f=e.target.files&&e.target.files[0]; if(!f) return;
  fnLabel.textContent=f.name||'';
  try{ if(lastURL) URL.revokeObjectURL(lastURL); }catch(_){ }
  const url=URL.createObjectURL(f); lastURL=url;
  img.onload=()=>{ lImg.src=img.src; float.classList.remove('visdiff-hidden'); apply(); updateLockOffsets(); };
  img.onerror=()=>{ alert('Impossible de charger cette image'); };
  img.src=url;
}
if(fileInput){ fileInput.addEventListener('change', handleFileSelection); }
btnPick.addEventListener('click', ()=>{
  try{
    const newInput=fileInput.cloneNode();
    newInput.value='';
    fileInput.replaceWith(newInput);
    fileInput=newInput;
    fileInput.addEventListener('change', handleFileSelection);
    fileInput.click();
  }catch(_){ }
});
// Close overlay (full destroy)
// file input change handled by handleFileSelection above
opInput.addEventListener('input',()=>{opacity=(parseInt(opInput.value,10)||0)/100;apply()});
scInput.addEventListener('input',()=>{scale=(parseInt(scInput.value,10)||100)/100;apply()});
xInput.addEventListener('change',()=>{posX=parseFloat(xInput.value)||0;apply();});
yInput.addEventListener('change',()=>{posY=parseFloat(yInput.value)||0;apply();});
blendSel.addEventListener('change',()=>{setBlend(blendSel.value)});
btnHide.addEventListener('click',()=>{float.classList.toggle('visdiff-hidden')});
btnCenter.addEventListener('click',()=>{if(img.src){const baseX=(window.innerWidth/2)-(img.naturalWidth*scale/2);const baseY=(window.innerHeight/2)-(img.naturalHeight*scale/2);if(anchorMode==='document'){posX=baseX+window.scrollX;posY=baseY+window.scrollY;}else{posX=baseX;posY=baseY;}apply();}});
function fitOverlayBasic(){
  if(!img.src) return null;
  console.log('ðŸ” ADAPTATION: ajustement de base + diagnostic');
  const imgWidth=img.naturalWidth, imgHeight=img.naturalHeight;
  const methods={
    scroll:{width:Math.max(document.documentElement.scrollWidth,document.body.scrollWidth),height:Math.max(document.documentElement.scrollHeight,document.body.scrollHeight)},
    offset:{width:Math.max(document.documentElement.offsetWidth,document.body.offsetWidth),height:Math.max(document.documentElement.offsetHeight,document.body.offsetHeight)},
    client:{width:Math.max(document.documentElement.clientWidth,document.body.clientWidth),height:Math.max(document.documentElement.clientHeight,document.body.clientHeight)},
    rect:(()=>{const html=document.documentElement.getBoundingClientRect();const body=document.body.getBoundingClientRect();return {width:Math.max(html.width,body.width),height:Math.max(html.height,body.height)};})()
  };
  let best=null, smallest=Infinity;
  Object.entries(methods).forEach(([k,d])=>{
    const s=Math.min(d.width/imgWidth,d.height/imgHeight);
    const rw=imgWidth*s,rh=imgHeight*s; const diff=Math.abs(rw-d.width)+Math.abs(rh-d.height); if(diff<smallest){smallest=diff;best={k,d,s,rw,rh,diffW:Math.abs(rw-d.width),diffH:Math.abs(rh-d.height)}}
  });
  scale=best.s; scInput.value=String(Math.round(scale*100));
  // Position de base: coin haut (0,0) dans l'espace actif
  if(anchorMode==='document'){ posX=0+window.scrollX; posY=0+window.scrollY; } else { posX=0; posY=0; }
  apply();
  console.log(`âœ… Base: mÃ©thode ${best.k}, Ã©chelle ${Math.round(scale*100)}%`);
  return best;
}
if(btnAdapt){
  btnAdapt.addEventListener('click', (ev)=>{
    if(!img.src) return;
    const prevMoved=userMovedOverlay; userMovedOverlay=false; // forcer recentrage si nÃ©cessaire dans diagnostic
    const fitInfo=fitOverlayBasic();
    const diag=diagnoseOverlayFit(ev);
    userMovedOverlay=prevMoved; // restaurer Ã©tat utilisateur
    console.log('ðŸ§ª Adaptation terminÃ©e', {fit:fitInfo, diagnostic:diag});
  });
}
btnReset.addEventListener('click',reset);
btnClose.addEventListener('click',closeUI);
gridChk.addEventListener('change',()=>{gOn=gridChk.checked;apply()});
gridSp.addEventListener('change',()=>{gSp=Math.max(1,parseInt(gridSp.value,10)||8);apply()});
gridOp.addEventListener('input',()=>{gOp=(parseInt(gridOp.value,10)||0)/100;apply()});
gridColor.addEventListener('change',()=>{gCol=gridColor.value||'#7aa2ff';apply()});
loupeChk.addEventListener('change',()=>{lOn=loupeChk.checked;apply()});
loupeSize.addEventListener('input',()=>{lSize=Math.max(80,parseInt(loupeSize.value,10)||160);apply()});
loupeZoom.addEventListener('input',()=>{lZ=(parseInt(loupeZoom.value,10)||300)/100;apply()});
// slider controls
sldChk.addEventListener('change',()=>{sOn=sldChk.checked;apply()});
sldPos.addEventListener('input',()=>{sPct=Math.max(0,Math.min(100,parseInt(sldPos.value,10)||0));apply()});
// Helper to update stored viewport-relative offsets when position changes while locked
function updateLockOffsets(){} // deprecated (noop)
// export button
btnExport.addEventListener('click',exportOverlay);
let drag=false,ox=0,oy=0;
// Pinch variables
let pinching=false,initialDist=0,initialScale=1;float.addEventListener('mousedown',e=>{drag=true;const curLeft = anchorMode==='document'? (posX - window.scrollX) : posX; const curTop = anchorMode==='document'? (posY - window.scrollY) : posY; ox=e.clientX-curLeft;oy=e.clientY-curTop;e.preventDefault()},{passive:false});
// mouse move: drag + loupe update
d.addEventListener('mousemove',e=>{if(drag){const newLeft=e.clientX-ox;const newTop=e.clientY-oy; if(anchorMode==='document'){posX=newLeft+window.scrollX;posY=newTop+window.scrollY;} else {posX=newLeft;posY=newTop;} apply()} if(lOn&&img.src){const x=e.clientX,y=e.clientY;const sz=lSize;loupe.style.left=Math.max(8,Math.min(x+16,window.innerWidth-sz-8))+'px';loupe.style.top=Math.max(8,Math.min(y+16,window.innerHeight-sz-8))+'px';lImg.src=img.src;const dispX=anchorMode==='document'? (posX-window.scrollX):posX;const dispY=anchorMode==='document'? (posY-window.scrollY):posY;const ix=(x-dispX)/scale;const iy=(y-dispY)/scale;lImg.style.transform=`translate(${(-ix*lZ+sz/2)}px,${(-iy*lZ+sz/2)}px) scale(${lZ})`}}
);
d.addEventListener('mouseup',()=>{drag=false});
// Touch support for dragging overlay and moving loupe
float.addEventListener('touchstart',e=>{const touches=e.touches;if(touches.length===1){const t=touches[0];drag=true;const curLeft=anchorMode==='document'?(posX-window.scrollX):posX;const curTop=anchorMode==='document'?(posY-window.scrollY):posY;ox=t.clientX-curLeft;oy=t.clientY-curTop;e.preventDefault()}else if(touches.length===2){pinching=true;const t1=touches[0],t2=touches[1];initialDist=Math.hypot(t1.clientX-t2.clientX,t1.clientY-t2.clientY);initialScale=scale;e.preventDefault()}},{passive:false});
d.addEventListener('touchmove',e=>{const touches=e.touches;if(touches.length===1){const t=touches[0];let handled=false;if(drag){const newLeft=t.clientX-ox;const newTop=t.clientY-oy;if(anchorMode==='document'){posX=newLeft+window.scrollX;posY=newTop+window.scrollY;} else {posX=newLeft;posY=newTop;} apply();handled=true}if(sliding){const x=t.clientX;sPct=Math.max(0,Math.min(100,(x/window.innerWidth)*100));apply();handled=true}if(lOn&&img.src){const x=t.clientX,y=t.clientY;const sz=lSize;loupe.style.left=Math.max(8,Math.min(x+16,window.innerWidth-sz-8))+'px';loupe.style.top=Math.max(8,Math.min(y+16,window.innerHeight-sz-8))+'px';lImg.src=img.src;const dispX=anchorMode==='document'?(posX-window.scrollX):posX;const dispY=anchorMode==='document'?(posY-window.scrollY):posY;const ix=(x-dispX)/scale;const iy=(y-dispY)/scale;lImg.style.transform=`translate(${(-ix*lZ+sz/2)}px,${(-iy*lZ+sz/2)}px) scale(${lZ})`}if(handled)e.preventDefault()}else if(touches.length===2&&pinching){const t1=touches[0],t2=touches[1];const dist=Math.hypot(t1.clientX-t2.clientX,t1.clientY-t2.clientY);scale=initialScale*(dist/initialDist);scale=Math.max(0.1,Math.min(5,scale));scInput.value=String(Math.round(scale*100));apply();e.preventDefault()}},{passive:false});
d.addEventListener('touchend',()=>{drag=false;sliding=false;pinching=false},{passive:true});
d.addEventListener('touchcancel',()=>{drag=false;sliding=false;pinching=false},{passive:true});
// slider handle drag
let sliding=false;handle.addEventListener('mousedown',e=>{sliding=true;e.preventDefault()},{passive:false});
handle.addEventListener('touchstart',e=>{sliding=true;e.preventDefault()},{passive:false});
d.addEventListener('mousemove',e=>{if(sliding){const x=e.clientX;sPct=Math.max(0,Math.min(100,(x/window.innerWidth)*100));apply()}});
d.addEventListener('mouseup',()=>{sliding=false});
d.addEventListener('mouseup',()=>{drag=false});
d.addEventListener('click', (e)=>{ const el = e.target.closest('.visdiff-btn'); if(el) try{ el.blur(); }catch(_){} });
d.addEventListener('touchend', (e)=>{ const el = e.target.closest('.visdiff-btn'); if(el) try{ el.blur(); }catch(_){} }, {passive:true});
d.addEventListener('keydown',e=>{if(!open)return;const step=e.shiftKey?10:1;const largeStep=e.shiftKey?100:40; // for viewport arrow scroll simulation
  if(e.key==='Escape'){closeUI()}
  else if(e.key==='ArrowLeft'){posX-=step;apply()}
  else if(e.key==='ArrowRight'){posX+=step;apply()}
  else if(e.key==='ArrowUp'){
    if(anchorMode==='document'){posY-=step;apply();}
    else { window.scrollBy(0,-step); }
  }
  else if(e.key==='ArrowDown'){
    if(anchorMode==='document'){posY+=step;apply();}
    else { window.scrollBy(0,step); }
  }
  else if(e.key==='PageDown'){
    if(anchorMode==='document'){posY+=largeStep;apply();}
    else { window.scrollBy(0,largeStep); }
  }
  else if(e.key==='PageUp'){
    if(anchorMode==='document'){posY-=largeStep;apply();}
    else { window.scrollBy(0,-largeStep); }
  }
  else if(e.key==='v'||e.key==='V'){
    // Convert coordinates so visual position is preserved
    if(anchorMode==='document'){
      // Convert to viewport coords
      posX = posX - window.scrollX; posY = posY - window.scrollY; anchorMode='viewport';
    } else {
      // Convert to document coords
      posX = posX + window.scrollX; posY = posY + window.scrollY; anchorMode='document';
    }
    apply(); console.log('Anchor mode:',anchorMode);
  }
  else if(e.key==='+'||e.key==='='){scale*=e.shiftKey?1.05:1.01;scInput.value=String(Math.round(scale*100));apply()}
  else if(e.key==='-'||e.key==='_'){scale/=e.shiftKey?1.05:1.01;scInput.value=String(Math.round(scale*100));apply()}
  else if(e.key==='d'||e.key==='D'){setBlend(blend==='difference'?'normal':'difference')}
  else if(e.key==='h'||e.key==='H'){toggleUI()}
  else if(e.key==='g'||e.key==='G'){gOn=!gOn;gridChk.checked=gOn;apply()}
  else if(e.key==='l'||e.key==='L'){lOn=!lOn;loupeChk.checked=lOn;apply()}
  else if(e.key==='s'||e.key==='S'){sOn=!sOn;sldChk.checked=sOn;apply()}
  else if(e.key==='x'||e.key==='X'){exportOverlay()}
  else if(e.key==='p'||e.key==='P'){snapshotPrompt()}
  else if(e.key==='o'||e.key==='O'){toggleUI(true)}
});
// Recalage pendant le scroll pour Ã©viter le dÃ©calage visuel
// Keep overlay visually synced when document anchored
let _scrollPending=false;window.addEventListener('scroll',()=>{if(!open)return;if(anchorMode!=='document')return;if(_scrollPending)return;_scrollPending=true;requestAnimationFrame(()=>{_scrollPending=false;apply();});},{passive:true});
async function exportOverlay(){try{if(!img.src){alert('Chargez une image d\'abord');return;}const w=window.innerWidth,h=window.innerHeight;const c=d.createElement('canvas');c.width=w;c.height=h;const cx=c.getContext('2d');cx.clearRect(0,0,w,h);cx.globalAlpha=opacity;if(sOn){cx.save();const sPx=Math.round((sPct/100)*w);cx.beginPath();cx.rect(0,0,sPx,h);cx.clip()}const dw=img.naturalWidth*scale,dh=img.naturalHeight*scale;const dx=anchorMode==='document'? (posX-window.scrollX):posX;const dy=anchorMode==='document'? (posY-window.scrollY):posY;cx.drawImage(img,dx,dy,dw,dh);if(sOn){cx.restore()}const a=d.createElement('a');a.href=c.toDataURL('image/png');a.download='overlay-viewport.png';a.click()}catch(e){alert('Export impossible: '+e)}}
async function snapshotPrompt(crop){let hid=false;try{if(!navigator.mediaDevices||!navigator.mediaDevices.getDisplayMedia){alert('Capture non supportÃ©e par ce navigateur');return}panel.classList.add('visdiff-hidden');handle.classList.add('visdiff-hidden');hid=true;const stream=await navigator.mediaDevices.getDisplayMedia({video:true});const track=stream.getVideoTracks()[0];const c=d.createElement('canvas');const cx=c.getContext('2d');let drew=false;let frameW=0,frameH=0;let drawSource=null;if('ImageCapture' in window){try{const ic=new ImageCapture(track);const bmp=await ic.grabFrame();frameW=bmp.width;frameH=bmp.height;c.width=frameW;c.height=frameH;cx.drawImage(bmp,0,0);drew=true;drawSource={type:'bmp',src:bmp};}catch(_){}}
if(!drew){const v=d.createElement('video');v.srcObject=stream;await v.play();await new Promise(r=>setTimeout(r,140));frameW=v.videoWidth;frameH=v.videoHeight;c.width=frameW;c.height=frameH;cx.drawImage(v,0,0,frameW,frameH);v.pause();drawSource={type:'video',src:v};}
if(crop && crop.w>3 && crop.h>3){const sx=frameW/window.innerWidth;const sy=frameH/window.innerHeight;const rx=Math.max(0,Math.round(crop.x*sx));const ry=Math.max(0,Math.round(crop.y*sy));const rw=Math.min(frameW-rx,Math.round(crop.w*sx));const rh=Math.min(frameH-ry,Math.round(crop.h*sy));const c2=d.createElement('canvas');c2.width=rw;c2.height=rh;const c2x=c2.getContext('2d');c2x.drawImage(drawSource.type==='video'?drawSource.src: c, rx, ry, rw, rh, 0, 0, rw, rh);const a=d.createElement('a');a.href=c2.toDataURL('image/png');a.download='snapshot-zone.png';a.click();}
else{const a=d.createElement('a');a.href=c.toDataURL('image/png');a.download='snapshot.png';a.click();}
track.stop();}catch(e){alert('Capture annulÃ©e ou Ã©chouÃ©e: '+e)}finally{if(hid){panel.classList.toggle('visdiff-hidden',!showUI)}handle.classList.toggle('visdiff-hidden',!sOn)}}

// Crop selection UI
function startCropSelection(){ cropRect.style.width='0px'; cropRect.style.height='0px'; cropLayer.classList.remove('visdiff-hidden'); let selecting=false; let startX=0,startY=0; let moved=false;
  function onDown(ev){ selecting=true; moved=false; const x=ev.clientX, y=ev.clientY; startX=x; startY=y; positionRect(x,y,0,0); ev.preventDefault(); }
  function onMove(ev){ if(!selecting) return; moved=true; const x=ev.clientX, y=ev.clientY; const rx=Math.min(startX,x), ry=Math.min(startY,y); const rw=Math.abs(x-startX), rh=Math.abs(y-startY); positionRect(rx,ry,rw,rh); }
  function onUp(ev){ if(!selecting) return; selecting=false; detach(); const rect = cropRect.getBoundingClientRect(); cropLayer.classList.add('visdiff-hidden'); const crop = { x: rect.left, y: rect.top, w: rect.width, h: rect.height }; if(!moved || crop.w<4 || crop.h<4){ return; } snapshotPrompt(crop); }
  function onKey(ev){ if(ev.key==='Escape'){ selecting=false; detach(); cropLayer.classList.add('visdiff-hidden'); } }
  function detach(){ d.removeEventListener('mousemove', onMove); d.removeEventListener('mouseup', onUp); d.removeEventListener('keydown', onKey); cropLayer.removeEventListener('mousedown', onDown); }
  function positionRect(x,y,w,h){ cropRect.style.left=x+'px'; cropRect.style.top=y+'px'; cropRect.style.width=w+'px'; cropRect.style.height=h+'px'; }
  cropLayer.addEventListener('mousedown', onDown, {passive:false}); d.addEventListener('mousemove', onMove); d.addEventListener('mouseup', onUp); d.addEventListener('keydown', onKey);
}

// Full page capture: scrolls and stitches the page
async function snapshotFullPage(){
  let hid=false; const originalY=window.scrollY;
  try{
    if(!navigator.mediaDevices||!navigator.mediaDevices.getDisplayMedia){alert('Capture non supportÃ©e par ce navigateur');return}
    panel.classList.add('visdiff-hidden'); handle.classList.add('visdiff-hidden'); hid=true;
    const stream=await navigator.mediaDevices.getDisplayMedia({video:true});
    const track=stream.getVideoTracks()[0];
    const video=document.createElement('video');
    video.srcObject=stream; await video.play();
    await new Promise(r=>setTimeout(r,180));
    const frameW=video.videoWidth, frameH=video.videoHeight;
    if(!frameW||!frameH){throw new Error('Dimensions de capture invalides');}
    const vw=window.innerWidth, vh=window.innerHeight;
    const sx=frameW/vw, sy=frameH/vh;
    const docH=Math.max(document.documentElement.scrollHeight, document.body.scrollHeight, vh);
    const outH=Math.min(Math.round(docH*sy), 30000); // clamp to avoid huge canvases
    const out=document.createElement('canvas'); out.width=frameW; out.height=outH; const ox=out.getContext('2d');
    let y=0; let destY=0;
    while(y < docH){
      window.scrollTo(0, y);
      await new Promise(r=>setTimeout(r,160));
      const visible=Math.min(vh, docH - y);
      const sh=Math.round(visible*sy);
      ox.drawImage(video, 0, 0, frameW, sh, 0, destY, frameW, sh);
      destY += sh; y += visible;
      if(destY >= outH-1) break;
    }
    window.scrollTo(0, originalY);
    track.stop(); video.pause();
    const a=document.createElement('a'); a.href=out.toDataURL('image/png'); a.download='snapshot-fullpage.png'; a.click();
  }catch(e){ alert('Capture annulÃ©e ou Ã©chouÃ©e: '+e) }
  finally{ if(hid){ panel.classList.toggle('visdiff-hidden',!showUI) } handle.classList.toggle('visdiff-hidden',!sOn) }
}
load(); apply(); updateLockOffsets(); openUI();
window.__VIS_DIFF__={open:openUI,close:closeUI,toggle:toggleUI}})();
  </script>

  <script>
    // Setup bookmarklet href at runtime to keep it readable in repo.
    (function(){
      // Use inline injector so it works even when this file is opened via file://
      const code = document.getElementById('visdiff-bookmarklet-code').textContent.trim();
      const href = 'javascript:'+encodeURIComponent(code);
      const a = document.getElementById('bookmarkletLink');
      const aTop = document.getElementById('bookmarkletLinkTop');
      a.setAttribute('href', href);
      aTop.setAttribute('href', href);
      // Copy to clipboard for users qui ne peuvent pas glisser
      document.getElementById('copyBookmarklet').addEventListener('click', async () => {
        try { await navigator.clipboard.writeText(href); alert('Bookmarklet copiÃ© dans le presseâ€‘papiers. Collezâ€‘le comme URL dâ€™un nouveau favori.'); }
        catch { alert('Impossible de copier automatiquement. Copiez le lien manuellement.'); }
      });
  // (demoHere button removed)
  // Guard left intentionally: if reintroduced, wrap in existence check.
    })();

    // Set default theme to Desjardins
    document.documentElement.setAttribute('data-theme', 'desjardins');

    // Tabs logic
    const tabs = document.querySelectorAll('.tab');
    const panels = document.querySelectorAll('.tabpanel');
    tabs.forEach(btn => btn.addEventListener('click', () => {
      tabs.forEach(b => { b.classList.toggle('active', b===btn); b.setAttribute('aria-selected', b===btn); });
      panels.forEach(p => { p.classList.toggle('active', p.id===btn.dataset.tab); p.setAttribute('aria-hidden', p.id!==btn.dataset.tab); });
    }));
  // (handler dÃ©placÃ© vers scripts/image-diff.js pour gÃ©rer l'Ã©tat hasDiff)

    // Image diff: custom file pickers
    (function(){
      document.querySelectorAll('.dropzone').forEach(dz=>{
        const pick = dz.querySelector('.pick');
        const input = dz.querySelector('input[type=file]');
        const fname = dz.querySelector('.fname');
        if(pick && input){
          pick.addEventListener('click',()=>{ try{ input.value=''; }catch(_){} input.click(); });
          input.addEventListener('change',()=>{ fname.textContent = input.files && input.files[0] ? input.files[0].name : ''; });
        }
      });
    })();

    // Remove sticky pressed state for buttons and link-buttons in main UI
    (function(){
      const unpress = (e)=>{ const el = e.target && (e.target.closest('button, a.btn, .btn, .pick, .tab, #bookmarkletLink, #bookmarkletLinkTop')); if(el){ try{ el.blur(); }catch(_){} } };
      document.addEventListener('mouseup', unpress);
      document.addEventListener('click', unpress);
      document.addEventListener('keyup', (e)=>{ if(e.key==='Enter' || e.key===' '){ unpress(e); } });
    })();
  </script>
</body>
<!--
  Note: injector.min.js is a tiny, self-contained version of overlay controls to load via bookmarklet.
  For local file:// usage, some browsers block javascript: URLs dragging. If so, host via a local server or GitHub Pages.
-->
